O make √© um utilit√°rio que determina automaticamente quais m√≥dulos de um programa precisam ser recompilados, e dispara instru√ß√µes para recompil√°-los. Para usar o make, voc√™ precisa escrever um arquivo chamado makefile que descreve as rela√ß√µes entre os arquivos do seu programa e declara as instru√ß√µes que devem ser executadas para atualizar cada arquivo.

Uma vez que um arquivo makefile tenha sido escrito de forma adequada para o seu programa, toda vez que houver uma mudan√ßa no c√≥digo fonte e que se deseje gerar um novo execut√°vel, basta digitar o comando make no terminal. O make ir√° ler o arquivo makefile do seu programa e se encarregar√° de recompilar apenas as partes necess√°rias para gerar um novo execut√°vel, o que pode reduzir consideravelmente o tempo de compila√ß√£o, principalmente quando aplicado a projetos grandes como o Firefox ou o Kernel do Linux.

Um makefile consiste de regras com o seguinte formato:

ALVO: DEPEND√äNCIA1 DEPEND√äNCIA2 ...
    INSTRU√á√ÉO1
    INSTRU√á√ÉO2
    ...
    ...
Um ALVO √© geralmente o nome de um arquivo que √© gerado pela regra, por exemplo, um arquivo execut√°vel ou um objeto. Uma DEPEND√äNCIA √© geralmente um arquivo de entrada que √© necess√°rio para criar o ALVO. Geralmente, um ALVO depende de v√°rios arquivos. INSTRU√á√ÉO √© uma a√ß√£o/instru√ß√£o que o make deve executar. Geralmente, uma regra possui v√°rias instru√ß√µes. Todas as linhas contendo instru√ß√µes devem come√ßar com um caractere de TAB.

No exemplo abaixo, podemos ver um makefile que compila um pequeno programa em C que computa uma √°rvore geradora m√≠nima.

mst_matrix: main.o prim.o wgraph.o lib_heap.a
    @echo "Executando instru√ß√µes de mst_matrix"
    gcc -o mst_matrix main.o prim.o wgraph.o heap.o  -L. -l_heap
    
main.o: main.c
    @echo "Executando instru√ß√µes de main.o"
    gcc -c main.c

prim.o: mst.h prim.c 
    @echo "Executando instru√ß√µes de prim.o"
    gcc -c prim.c

wgraph.o: wgraph.h wgraph.c
    @echo "Executando instru√ß√µes de wgraph.o"
    gcc -c wgraph.c
    
heap.o: priority_queue.h heap.c
    @echo "Executando instru√ß√µes de heap.o"
    gcc -c heap.c
    
lib_heap.a: heap.o
    @echo "Executando instru√ß√µes de lib_heap.a"
    ar rcs lib_heap.a heap.o
    
clean: 
    @echo "Limpando o Projeto"
    rm -rf *.o mst_matrix
Vejamos ent√£o um pequeno exemplo de execu√ß√£o do make quando este processar o makefile acima. Digamos que o usu√°rio invocou o make com o seguinte comando:

$ make main.o
Vamos primeiro supor que estamos trabalhando com um /clean build/, i.e., que nunca tenhamos compilado esse projeto antes. No comando acima, o usu√°rio pede para o make executar a regra main.o (vamos nos referir a regra cujo alvo √© xxx simplesmente por xxx). O make ent√£o verificar√° se alguma depend√™ncia dessa regra (neste caso, apenas main.c) foi atualizada desde a √∫ltima compila√ß√£o. No caso, esse projeto nunca foi compilado antes, ent√£o a regra est√° ‚Äúdesatualizada‚Äù. Portanto, ao executar o comando acima o make executar√° as instru√ß√µes da regra.

@echo "Gerando o objeto do arquivo principal"
gcc -c main.c
Agora, imagine que o usu√°rio invocou o comando abaixo novamente:

$ make main.o
O make ent√£o verificar√° se alguma depend√™ncia dessa regra (main.c) foi atualizada desde a √∫ltima compila√ß√£o. Digamos que n√£o tenha havido nenhuma edi√ß√£o ao arquivo main.c. Ent√£o nesse caso, o make n√£o executar√° nenhuma instru√ß√£o, pois ele sabe que o artefato gerado pela execu√ß√£o dessa regra (o arquivo main.o) √© um arquivo que foi constru√≠do com a vers√£o mais recente dos arquivos dependentes. Agora, imagine novamente que usu√°rio modificou o arquivo main.c e invocou o comando acima novamente. Agora, o make percebe que a depend√™ncia da regra main.o foi atualizada e portanto que o objeto main.o foi constru√≠do com uma vers√£o velha do arquivo main.c e que portanto precisa atualizar o arquivo main.o e para isso ele executa as instru√ß√µes da regra main.o. Nesse caso ele executar√° os comandos da regra main.o, atualizando o arquivo objeto main.o:

@echo "Executando instru√ß√µes de main.o"
gcc -c main.c
Neste exerc√≠cio, vamos fazer uma vers√£o simplificado do make em que assumimos que todas as regras est√£o desatualizadas, ou seja, faremos a execu√ß√£o do make com um /clean build/. Entretanto note que n√£o seria dif√≠cil estender a nossa vers√£o para a vers√£o mais robusta do make. Para isso, bastaria que compar√°ssemos as datas de modifica√ß√£o dos arquivos de depend√™ncia com as datas desses arquivos no momento da √∫ltima execu√ß√£o da regra. Se todas as datas permanecem iguais, ent√£o o arquivo gerado pela execu√ß√£o da regra permanece atualizado; caso contr√°rio, o arquivo resultante da execu√ß√£o da regra foi constru√≠do com arquivos desatualizados e portanto as instru√ß√µes da regra devem ser executadas novamente.

Como comentado anteriormente, vamos sempre assumir que as regras est√£o desatualizadas. Agora, vamos ver como seria a execu√ß√£o do comando abaixo com essa hip√≥tese.

make mst_matrix
Antes de executar as instru√ß√µes dessa regra, precisamos executar as instru√ß√µes das depend√™ncias, se estas forem alvos de regras. No caso de uma depend√™ncia que n√£o √© alvo de uma regra, ou seja, uma depend√™ncia que √© um arquivo que n√£o √© gerado pelo processo de compila√ß√£o, n√£o h√° regra para ser executada e ent√£o n√£o precisamos fazer nada. No caso da regra mst_matrix, as quatro depend√™ncias (main.o, prim.o, wgraph.o, lib_heap.a) s√£o alvos de regras, ent√£o precisamos executar as instru√ß√µes delas. Note que as regras main.o, prim.o e wgraph.o s√≥ possuem depend√™ncias que n√£o s√£o alvos de outras regras, ent√£o podemos executar as instru√ß√µes dessas regras sem ter que nos preocupar em coloc√°-las ap√≥s as instru√ß√µes de outras regras. Entretanto, a regra lib_heap.a possui uma depend√™ncia que √© alvo de uma regra: heap.o. Isso significa que antes de executar as instru√ß√µes de lib_heap.a, precisamos executar as instru√ß√µes de heap.o. Por sua vez, a regra heap.o s√≥ possui depend√™ncias que n√£o s√£o alvos de regras, ent√£o podemos executar as instru√ß√µes da regra heap.o livremente. Assim, uma das poss√≠veis execu√ß√µes v√°lidas do make seria:

@echo "Executando instru√ß√µes de main.o"
gcc -c main.c
@echo "Executando instru√ß√µes de prim.o"
gcc -c prim.c
@echo "Executando instru√ß√µes de wgraph.o"
gcc -c wgraph.c
@echo "Executando instru√ß√µes de heap.o"
gcc -c heap.c
@echo "Executando instru√ß√µes de lib_heap.a"
ar rcs lib_heap.a heap.o
@echo "Executando instru√ß√µes de mst_matrix"
gcc -o mst_matrix main.o prim.o wgraph.o heap.o  -L. -l_heap
Note como as instru√ß√µes de heap.o precedem as instru√ß√µes de lib_heap.a, j√° que heap.o √© uma depend√™ncia da regra lib_heap.a. Note tamb√©m como as instru√ß√µes de lib_heap.a, main.o, prim.o, wgraph.o precedem as instru√ß√µes de mst_matrix, j√° que aquelas s√£o depend√™ncias desta. Por fim, abaixo podemos ver uma outra execu√ß√£o poss√≠vel de ser realizada pelo make.

@echo "Executando instru√ß√µes de main.o"
gcc -c main.c
@echo "Executando instru√ß√µes de heap.o"
gcc -c heap.c
@echo "Executando instru√ß√µes de prim.o"
gcc -c prim.c
@echo "Executando instru√ß√µes de lib_heap.a"
ar rcs lib_heap.a heap.o
@echo "Executando instru√ß√µes de wgraph.o"
gcc -c wgraph.c
@echo "Executando instru√ß√µes de mst_matrix"
gcc -o mst_matrix main.o prim.o wgraph.o heap.o  -L. -l_heap
Por fim, cabe observar que as depend√™ncias de uma regra n√£o s√£o necessariamente todas alvos de regras ou todas n√£o alvos de regras, como no exemplo acima. Uma regra pode conter algumas depend√™ncias que s√£o alvos de regras e outras que n√£o s√£o, embora isso n√£o seja muito comum na pr√°tica.

Crit√©rios importantes
Independentemente dos resultados dos testes, o n√£o cumprimento dos crit√©rios abaixo implicar√° em nota zero para esta atividade. Qualquer d√∫vida, entre em contato.

Voc√™ deve usar algum algoritmo visto em aula para resolver o problema. Solu√ß√µes por for√ßa bruta (testar todas as permuta√ß√µes, por exemplo) ser√£o desconsideradas mesmo que passem em todos os testes.
As √∫nicas estruturas de dados que voc√™ poder√° usar da biblioteca padr√£o s√£o: vetores/matrizes (est√°ticos e/ou din√¢micos), listas, pilhas, strings, hashs/dicion√°rios/maps.
Se voc√™ precisar, voc√™ pode usar uma rotina de ordena√ß√£o fornecida pela sua linguagem.
üö® Aqui n√° p√°gina HTML do moodle, no lugar de um caracter TAB, est√° aparecendo 4 espa√ßos. Aqui, na p√°gina, eu n√£o consigo for√ßar esse caracter TAB, nos casos de teste todas as linhas com instru√ß√µes come√ßam com TAB e n√£o com 4 espa√ßos. Se voc√™ copiar os exemplos aqui da p√°gina HTML para usar como caso de teste para testar o seu programa, lembre-se de trocar os espa√ßos por caracteres TAB no in√≠cio das intru√ß√µes.
Dicas para quem decidir fazer o Problema em C
As fun√ß√µes fgets (stdio.h) e strtok (string.h) podem ser √∫teis.
Se voc√™ precisar implementar uma tabela de s√≠mbolos, voc√™ pode usar a estrutura de dados que voc√™ achar mais f√°cil (vetor est√°tico, lista ligada, tabela hash, √°rvore).
Talvez voc√™ queira alocar um vetor est√°tico com tamanho suficiente para armazenar as instru√ß√µes de qualquer inst√¢ncia poss√≠vel (para n√£o ter que programar uma lista ligada).
Entrada
A primeira linha da entrada cont√©m uma cadeia make <alvo>, onde <alvo> √© o nome de um dos alvos do arquivo makefile. As pr√≥ximas linhas cont√™m o conte√∫do do arquivo makefile. O fim da entrada √© marcado por uma linha com a frase FIM. Voc√™ pode assumir que n√£o h√° linhas em branco na entrada, que cada caso de teste cont√©m no m√°ximo 500 regras e que, ao todo, cada caso de teste tem no m√°ximo 1000 instru√ß√µes. Ademais, voc√™ pode assumir que cada instru√ß√£o tem no m√°ximo 200 caracteres.

Sa√≠da
A sa√≠da do seu programa deve consistir na sequ√™ncia de instru√ß√µes que devem ser executadas pelo make para que a regra <alvo> seja executada. Vamos nos referir a uma regra foo se o alvo desse regra √© foo. Note que se uma regra bar √© um pr√©-requisito de uma regra foo, ent√£o as instru√ß√µes da regra bar devem ser executadas antes das instru√ß√µes da regra foo. Ademais, as instru√ß√µes dentro de uma regra n√£o podem ter suas ordens alteradas.

Exemplos
Teste 01

Entrada:

make all
all: graph.o main.o
    @echo "construindo o programa principal"
    gcc -o main graph.o main.o
graph.o: graph.c graph.h
    gcc -c graph.c
main.o: main.c
    gcc -c main.c
clean:
    rm *.o
FIM
Sa√≠da:

gcc -c graph.c
gcc -c main.c
@echo "construindo o programa principal"
gcc -o main graph.o main.o
Teste 02

Entrada:

make all
out_dir: clean
    mkdir out_dir
img_dir: out_dir
    mkdir out_dir/figs
all: img_dir clean
    pdflatex --out-dir outdir main.tex
    bibtex main
    pdflatex main.tex
    pdflatex main.tex
clean:
    rm -f out_dir
FIM
Sa√≠da:

rm -f out_dir
mkdir out_dir
mkdir out_dir/figs
pdflatex --out-dir outdir main.tex
bibtex main
pdflatex main.tex
pdflatex main.tex